package CluelessPackage;


import java.util.ArrayList;
import java.util.Collection;
import java.util.WeakHashMap;

public class GameBoard {

	private ArrayList<Location> boardLocations = new ArrayList<Location>();
	private int numberOfLocations = 21;
	WeakHashMap <User, Integer>userLocations;

	
	/**
	 * This class implements the singleton pattern for global access.
	 */
private static GameBoard thisBoard = null;
	
	private GameBoard(){
		userLocations = new WeakHashMap<User, Integer>();
	}

	/**
	 * @return the singleton instance of the gameboard.
	 */
	 static GameBoard getBoard() {
		if (thisBoard == null){
			thisBoard = new GameBoard();
		}
		return thisBoard;
	}

	
	
	 void initialize() {
		createLocations();
		connectLocations();
	}




	private void createLocations() {
		for (int i = 0; i < numberOfLocations; i++){
			if ( i == 0 || i==2 || i == 4 ||
				 i == 8 || i==10 || i == 12 ||
				 i == 16|| i==18 || i == 20){
				boardLocations.add(new Location(i, false));
			}
			else{
				boardLocations.add(new Location(i, true));
			}
		}
	}

	private void connectLocations() {
		ArrayList<Location> links = new ArrayList<Location>();
		links.add(boardLocations.get(1));
		links.add(boardLocations.get(5));
		boardLocations.get(0).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(0));
		links.add(boardLocations.get(2));
		boardLocations.get(1).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(1));
		links.add(boardLocations.get(3));
		links.add(boardLocations.get(6));
		boardLocations.get(2).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(2));
		links.add(boardLocations.get(4));
		boardLocations.get(3).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(3));
		links.add(boardLocations.get(7));
		boardLocations.get(4).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(0));
		links.add(boardLocations.get(8));
		boardLocations.get(5).addLinks(links);
		links.clear();
		
		links.add(boardLocations.get(2));
		links.add(boardLocations.get(10));
		boardLocations.get(6).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(4));
		links.add(boardLocations.get(12));
		boardLocations.get(7).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(5));
		links.add(boardLocations.get(9));
		links.add(boardLocations.get(13));
		boardLocations.get(8).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(8));
		links.add(boardLocations.get(10));
		boardLocations.get(9).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(6));
		links.add(boardLocations.get(9));
		links.add(boardLocations.get(11));
		links.add(boardLocations.get(14));
		boardLocations.get(10).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(10));
		links.add(boardLocations.get(12));
		boardLocations.get(11).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(7));
		links.add(boardLocations.get(11));
		links.add(boardLocations.get(15));
		boardLocations.get(12).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(8));
		links.add(boardLocations.get(16));
		boardLocations.get(13).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(10));
		links.add(boardLocations.get(18));
		boardLocations.get(14).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(12));
		links.add(boardLocations.get(20));
		boardLocations.get(15).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(13));
		links.add(boardLocations.get(17));
		boardLocations.get(16).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(16));
		links.add(boardLocations.get(18));
		boardLocations.get(17).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(14));
		links.add(boardLocations.get(17));
		links.add(boardLocations.get(19));
		boardLocations.get(18).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(18));
		links.add(boardLocations.get(20));
		boardLocations.get(19).addLinks(links);
		links.clear(); 
		
		links.add(boardLocations.get(19));
		links.add(boardLocations.get(15));
		boardLocations.get(20).addLinks(links);

	}

	int[] getValidMoves(User activeUser) {
		
		//make a list of this user's valid moves (starts off empty).
		ArrayList<Location> validMoveLocations = new ArrayList<Location>();
		
		//figure-out where the user is.
		Location playerCurrentLocation = getPlayerLocation(activeUser);
		

		for (Location l : playerCurrentLocation.adjacencyList){
			//if a connected location is a room or an empty hallway, then this is a valid location to move to.
			if (!l.isHallway || locationIsEmpty(l.locNumber)){
				validMoveLocations.add(l);}}
		int[] validMoveIndicies = new int[validMoveLocations.size()];
		for (int i = 0; i<validMoveLocations.size(); i++){
			validMoveIndicies[i] = validMoveLocations.get(i).locNumber;
		}
		return validMoveIndicies;
	}
	

	
	
		private boolean locationIsEmpty(int locNumber) {
			Collection<Integer> locationCollection = userLocations.values();
			for (Integer i: locationCollection){
				if (i.intValue() == locNumber && userLocations.containsValue(i)){
					return false;
				}			
			}
			return true;
		}
		
	
	
	void putUserOnStartingLocation(User user, int i) {
		userLocations.put(user, new Integer(i));
}



	void moveUserTo(User user, int moveTo) {
		//remove the user from current location
		userLocations.remove(user);
		
		//and add the user to the new location
		userLocations.put(user, new Integer(moveTo));
		

		if (userIsInARoom(user) && user.isInTheGame){
			user.mustMakeSuggestion();
		}
		
	}




	private  boolean userIsInARoom(User user) {
		//get User's locations index
		int locNum = userLocations.get(user).intValue();
		
		for(Location l: boardLocations){
			if (l.locNumber == locNum && !l.isHallway){
				return true;
		}
			}
			return false;
		}
	

 Location getPlayerLocation(User user) {
	 int locationNumber = userLocations.get(user).intValue();
	 for (Location l : boardLocations){
		 if (l.locNumber == locationNumber){
			 return l;
		 }
		 }
	 return null;
	 }
	 
	 
 
/*Location playerCurrentLocation = null;


for (Location l : boardLocations){
	if (l.usersOccputingLocation.contains(activeUser)){
		playerCurrentLocation = l;
	}
}
	return playerCurrentLocation;
}
*/
 /*ArrayList<Location> getOccupoedlocations() {
	ArrayList<Location> occupiedLocations = new ArrayList<Location>();
	
	//Get all of the locations which are inhabited
	for  (Location l: boardLocations){
		if (!l.usersOccputingLocation.isEmpty()){
			occupiedLocations.add(l);
			}
	}
	return occupiedLocations;

}
*/	
void moveUserToSuggester(User u, User suggestingUser) {
	moveUserTo(u, userLocations.get(suggestingUser).intValue());
	
}

	
	
}
		
			
		

